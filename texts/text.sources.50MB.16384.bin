o_user(argp, &abinfo,
				    sizeof(abinfo)) ? -EFAULT : 0;
	case SNDCTL_DSP_GETOPTR:
		if (!(file->f_mode & FMODE_WRITE))
			return -EINVAL;
		if (codec_independent_spdif_locked > 0) {
			if (!dmabuf->ready && (val = prog_dmabuf(state, 2)) != 0)
				return val;
		} else {
			if (controller_independent_spdif_locked > 0) {
				if (!dmabuf->ready && (val = prog_dmabuf(state, 3)) != 0)
					return val;
			} else {
				if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
					return val;
			}
		}
		spin_lock_irqsave(&state->card->lock, flags);
		val = ali_get_free_write_space(state);
		cinfo.bytes = dmabuf->total_bytes;
		cinfo.ptr = dmabuf->hwptr;
		cinfo.blocks = val / dmabuf->userfragsize;
		if (codec_independent_spdif_locked > 0) {
			if (dmabuf->mapped && (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
				dmabuf->count += val;
				dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
				__ali_update_lvi(state, 2);
			}
		} else {
			if (controller_independent_spdif_locked > 0) {
				if (dmabuf->mapped && (dmabuf->trigger & SPDIF_ENABLE_OUTPUT)) {
					dmabuf->count += val;
					dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
					__ali_update_lvi(state, 3);
				}
			} else {
				if (dmabuf->mapped && (dmabuf->trigger & PCM_ENABLE_OUTPUT)) {
					dmabuf->count += val;
					dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
					__ali_update_lvi(state, 0);
				}
			}
		}
		spin_unlock_irqrestore(&state->card->lock, flags);
#if defined(DEBUG) || defined(DEBUG_MMAP)
		printk("SNDCTL_DSP_GETOPTR %d, %d, %d, %d\n", cinfo.bytes,
		       cinfo.blocks, cinfo.ptr, dmabuf->count);
#endif
		return copy_to_user(argp, &cinfo, sizeof(cinfo))? -EFAULT : 0;
	case SNDCTL_DSP_GETISPACE:
		if (!(file->f_mode & FMODE_READ))
			return -EINVAL;
		if (!dmabuf->ready && (val = prog_dmabuf(state, 1)) != 0)
			return val;
		spin_lock_irqsave(&state->card->lock, flags);
		abinfo.bytes = ali_get_available_read_data(state);
		abinfo.fragsize = dmabuf->userfragsize;
		abinfo.fragstotal = dmabuf->userfrags;
		abinfo.fragments = abinfo.bytes / dmabuf->userfragsize;
		spin_unlock_irqrestore(&state->card->lock, flags);
#if defined(DEBUG) || defined(DEBUG_MMAP)
		printk("SNDCTL_DSP_GETISPACE %d, %d, %d, %d\n",
		       abinfo.bytes, abinfo.fragsize, abinfo.fragments,
		       abinfo.fragstotal);
#endif
		return copy_to_user(argp, &abinfo,
				    sizeof(abinfo)) ? -EFAULT : 0;
	case SNDCTL_DSP_GETIPTR:
		if (!(file->f_mode & FMODE_READ))
			return -EINVAL;
		if (!dmabuf->ready && (val = prog_dmabuf(state, 0)) != 0)
			return val;
		spin_lock_irqsave(&state->card->lock, flags);
		val = ali_get_available_read_data(state);
		cinfo.bytes = dmabuf->total_bytes;
		cinfo.blocks = val / dmabuf->userfragsize;
		cinfo.ptr = dmabuf->hwptr;
		if (dmabuf->mapped && (dmabuf->trigger & PCM_ENABLE_INPUT)) {
			dmabuf->count -= val;
			dmabuf->swptr = (dmabuf->swptr + val) % dmabuf->dmasize;
			__ali_update_lvi(state, 1);
		}
		spin_unlock_irqrestore(&state->card->lock, flags);
#if defined(DEBUG) || defined(DEBUG_MMAP)
		printk("SNDCTL_DSP_GETIPTR %d, %d, %d, %d\n", cinfo.bytes,
		       cinfo.blocks, cinfo.ptr, dmabuf->count);
#endif
		return copy_to_user(argp, &cinfo, sizeof(cinfo))? -EFAULT: 0;
	case SNDCTL_DSP_NONBLOCK:
#ifdef DEBUG
		printk("SNDCTL_DSP_NONBLOCK\n");
#endif
		file->f_flags |= O_NONBLOCK;
		return 0;
	case SNDCTL_DSP_GETCAPS:
#ifdef DEBUG
		printk("SNDCTL_DSP_GETCAPS\n");
#endif
		return put_user(DSP_CAP_REALTIME | DSP_CAP_TRIGGER |
				DSP_CAP_MMAP | DSP_CAP_BIND, p);
	case SNDCTL_DSP_GETTRIGGER:
		val = 0;
#ifdef DEBUG
		printk("SNDCTL_DSP_GETTRIGGER 0x%x\n", dmabuf->trigger);
#endif
		return put_user(dmabuf->trigger, p);
	case SNDCTL_DSP_SETTRIGGER:
		if (get_user(val, p))
			return -EFAULT;
#if defined(DEBUG) || defined(DEBUG_MMAP)
		printk("SNDCTL_DSP_SETTRIGGER 0x%x\n", val);
#endif
		if (!(val & PCM_ENABLE_INPUT) && dmabuf->enable == ADC_RUNNING) {
			stop_adc(state);
		}
		if (!(val & PCM_ENABLE_OUTPUT) && dmabuf->enable == DAC_RUNNING) {
			stop_dac(state);
		}
		if (!(val & SPDIF_ENABLE_OUTPUT) && dmabuf->enable == CODEC_SPDIFOUT_RUNNING) {
			stop_spdifout(state);
		}
		if (!(val & SPDIF_ENABLE_OUTPUT) && dmabuf->enable == CONTROLLER_SPDIFOUT_RUNNING) {
			stop_spdifout(state);
		}
		dmabuf->trigger = val;
		if (val & PCM_ENABLE_OUTPUT && !(dmabuf->enable & DAC_RUNNING)) {
			if (!dmabuf->write_channel) {
				dmabuf->ready = 0;
				dmabuf->write_channel = state->card->alloc_pcm_channel(state->card);
				if (!dmabuf->write_channel)
					return -EBUSY;
			}
			if (!dmabuf->ready && (ret = prog_dmabuf(state, 0)))
				return ret;
			if (dmabuf->mapped) {
				spin_lock_irqsave(&state->card->lock, flags);
				ali_update_ptr(state);
				dmabuf->count = 0;
				dmabuf->swptr = dmabuf->hwptr;
				dmabuf->count = ali_get_free_write_space(state);
				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
				__ali_update_lvi(state, 0);
				spin_unlock_irqrestore(&state->card->lock,
						       flags);
			} else
				start_dac(state);
		}
		if (val & SPDIF_ENABLE_OUTPUT && !(dmabuf->enable & CODEC_SPDIFOUT_RUNNING)) {
			if (!dmabuf->codec_spdifout_channel) {
				dmabuf->ready = 0;
				dmabuf->codec_spdifout_channel = state->card->alloc_codec_spdifout_channel(state->card);
				if (!dmabuf->codec_spdifout_channel)
					return -EBUSY;
			}
			if (!dmabuf->ready && (ret = prog_dmabuf(state, 2)))
				return ret;
			if (dmabuf->mapped) {
				spin_lock_irqsave(&state->card->lock, flags);
				ali_update_ptr(state);
				dmabuf->count = 0;
				dmabuf->swptr = dmabuf->hwptr;
				dmabuf->count = ali_get_free_write_space(state);
				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
				__ali_update_lvi(state, 2);
				spin_unlock_irqrestore(&state->card->lock,
						       flags);
			} else
				start_spdifout(state);
		}
		if (val & SPDIF_ENABLE_OUTPUT && !(dmabuf->enable & CONTROLLER_SPDIFOUT_RUNNING)) {
			if (!dmabuf->controller_spdifout_channel) {
				dmabuf->ready = 0;
				dmabuf->controller_spdifout_channel = state->card->alloc_controller_spdifout_channel(state->card);
				if (!dmabuf->controller_spdifout_channel)
					return -EBUSY;
			}
			if (!dmabuf->ready && (ret = prog_dmabuf(state, 3)))
				return ret;
			if (dmabuf->mapped) {
				spin_lock_irqsave(&state->card->lock, flags);
				ali_update_ptr(state);
				dmabuf->count = 0;
				dmabuf->swptr = dmabuf->hwptr;
				dmabuf->count = ali_get_free_write_space(state);
				dmabuf->swptr = (dmabuf->swptr + dmabuf->count) % dmabuf->dmasize;
				__ali_update_lvi(state, 3);
				spin_unlock_irqrestore(&state->card->lock, flags);
			} else
				start_spdifout(state);
		}
		if (val & PCM_ENABLE_INPUT && !(dmabuf->enable & ADC_RUNNING)) {
			if (!dmabuf->read_channel) {
				dmabuf->ready = 0;
				dmabuf->read_channel = state->card->alloc_rec_pcm_channel(state->card);
				if (!dmabuf->read_channel)
					return -EBUSY;
			}
			if (!dmabuf->ready && (ret = prog_dmabuf(state, 1)))
				return ret;
			if (dmabuf->mapped) {
				spin_lock_irqsave(&state->card->lock,
						  flags);
				ali_update_ptr(state);
				dmabuf->swptr = dmabuf->hwptr;
				dmabuf->count = 0;
				spin_unlock_irqrestore(&state->card->lock, flags);
			}
			ali_update_lvi(state, 1);
			start_adc(state);
		}
		return 0;
	case SNDCTL_DSP_SETDUPLEX:
#ifdef DEBUG
		printk("SNDCTL_DSP_SETDUPLEX\n");
#endif
		return -EINVAL;
	case SNDCTL_DSP_GETODELAY:
		if (!(file->f_mode & FMODE_WRITE))
			return -EINVAL;
		spin_lock_irqsave(&state->card->lock, flags);
		ali_update_ptr(state);
		val = dmabuf->count;
		spin_unlock_irqrestore(&state->card->lock, flags);
#ifdef DEBUG
		printk("SNDCTL_DSP_GETODELAY %d\n", dmabuf->count);
#endif
		return put_user(val, p);
	case SOUND_PCM_READ_RATE:
#ifdef DEBUG
		printk("SOUND_PCM_READ_RATE %d\n", dmabuf->rate);
#endif
		return put_user(dmabuf->rate, p);
	case SOUND_PCM_READ_CHANNELS:
#ifdef DEBUG
		printk("SOUND_PCM_READ_CHANNELS\n");
#endif
		return put_user(2, p);
	case SOUND_PCM_READ_BITS:
#ifdef DEBUG
		printk("SOUND_PCM_READ_BITS\n");
#endif
		return put_user(AFMT_S16_LE, p);
	case SNDCTL_DSP_SETSPDIF:	/* Set S/PDIF Control register */
#ifdef DEBUG
		printk("SNDCTL_DSP_SETSPDIF\n");
#endif
		if (get_user(val, p))
			return -EFAULT;
		/* Check to make sure the codec supports S/PDIF transmitter */
		if ((state->card->ac97_features & 4)) {
			/* mask out the transmitter speed bits so the user can't set them */
			val &= ~0x3000;
			/* Add the current transmitter speed bits to the passed value */
			ret = ali_ac97_get(codec, AC97_SPDIF_CONTROL);
			val |= (ret & 0x3000);
			ali_ac97_set(codec, AC97_SPDIF_CONTROL, val);
			if (ali_ac97_get(codec, AC97_SPDIF_CONTROL) != val) {
				printk(KERN_ERR "ali_audio: Unable to set S/PDIF configuration to 0x%04x.\n", val);
				return -EFAULT;
			}
		}
#ifdef DEBUG
		else
			printk(KERN_WARNING "ali_audio: S/PDIF transmitter not avalible.\n");
#endif
		return put_user(val, p);
	case SNDCTL_DSP_GETSPDIF:	/* Get S/PDIF Control register */
#ifdef DEBUG
		printk("SNDCTL_DSP_GETSPDIF\n");
#endif
		if (get_user(val, p))
			return -EFAULT;
		/* Check to make sure the codec supports S/PDIF transmitter */
		if (!(state->card->ac97_features & 4)) {
#ifdef DEBUG
			printk(KERN_WARNING "ali_audio: S/PDIF transmitter not avalible.\n");
#endif
			val = 0;
		} else {
			val = ali_ac97_get(codec, AC97_SPDIF_CONTROL);
		}

		return put_user(val, p);
//end add support spdif out
//add support 4,6 channel
	case SNDCTL_DSP_GETCHANNELMASK:
#ifdef DEBUG
		printk("SNDCTL_DSP_GETCHANNELMASK\n");
#endif
		if (get_user(val, p))
			return -EFAULT;
		/* Based on AC'97 DAC support, not ICH hardware */
		val = DSP_BIND_FRONT;
		if (state->card->ac97_features & 0x0004)
			val |= DSP_BIND_SPDIF;
		if (state->card->ac97_features & 0x0080)
			val |= DSP_BIND_SURR;
		if (state->card->ac97_features & 0x0140)
			val |= DSP_BIND_CENTER_LFE;
		return put_user(val, p);
	case SNDCTL_DSP_BIND_CHANNEL:
#ifdef DEBUG
		printk("SNDCTL_DSP_BIND_CHANNEL\n");
#endif
		if (get_user(val, p))
			return -EFAULT;
		if (val == DSP_BIND_QUERY) {
			val = DSP_BIND_FRONT;	/* Always report this as being enabled */
			if (state->card->ac97_status & SPDIF_ON)
				val |= DSP_BIND_SPDIF;
			else {
				if (state->card->ac97_status & SURR_ON)
					val |= DSP_BIND_SURR;
				if (state->card->
				    ac97_status & CENTER_LFE_ON)
					val |= DSP_BIND_CENTER_LFE;
			}
		} else {	/* Not a query, set it */
			if (!(file->f_mode & FMODE_WRITE))
				return -EINVAL;
			if (dmabuf->enable == DAC_RUNNING) {
				stop_dac(state);
			}
			if (val & DSP_BIND_SPDIF) {	/* Turn on SPDIF */
				/*  Ok, this should probably define what slots
				 *  to use. For now, we'll only set it to the
				 *  defaults:
				 * 
				 *   non multichannel codec maps to slots 3&4
				 *   2 channel codec maps to slots 7&8
				 *   4 channel codec maps to slots 6&9
				 *   6 channel codec maps to slots 10&11
				 *
				 *  there should be some way for the app to
				 *  select the slot assignment.
				 */
				i_scr = inl(state->card->iobase + ALI_SCR);
				if (codec_independent_spdif_locked > 0) {

					if ((i_scr & 0x00300000) == 0x00100000) {
						ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
					} else {
						if ((i_scr & 0x00300000) == 0x00200000) {
							ali_set_spdif_output(state, AC97_EA_SPSA_6_9, codec_independent_spdif_locked);
						} else {
							if ((i_scr & 0x00300000) == 0x00300000) {
								ali_set_spdif_output(state, AC97_EA_SPSA_10_11, codec_independent_spdif_locked);
							}
						}
					}
				} else {	/* codec spdif out (pcm out share ) */
					ali_set_spdif_output(state, AC97_EA_SPSA_3_4, dmabuf->rate);	//I do not modify
				}

				if (!(state->card->ac97_status & SPDIF_ON))
					val &= ~DSP_BIND_SPDIF;
			} else {
				int mask;
				int channels;
				/* Turn off S/PDIF if it was on */
				if (state->card->ac97_status & SPDIF_ON)
					ali_set_spdif_output(state, -1, 0);
				mask =
				    val & (DSP_BIND_FRONT | DSP_BIND_SURR |
					   DSP_BIND_CENTER_LFE);
				switch (mask) {
				case DSP_BIND_FRONT:
					channels = 2;
					break;
				case DSP_BIND_FRONT | DSP_BIND_SURR:
					channels = 4;
					break;
				case DSP_BIND_FRONT | DSP_BIND_SURR | DSP_BIND_CENTER_LFE:
					channels = 6;
					break;
				default:
					val = DSP_BIND_FRONT;
					channels = 2;
					break;
				}
				ali_set_dac_channels(state, channels);
				/* check that they really got turned on */
				if (!state->card->ac97_status & SURR_ON)
					val &= ~DSP_BIND_SURR;
				if (!state->card->
				    ac97_status & CENTER_LFE_ON)
					val &= ~DSP_BIND_CENTER_LFE;
			}
		}
		return put_user(val, p);
	case SNDCTL_DSP_MAPINBUF:
	case SNDCTL_DSP_MAPOUTBUF:
	case SNDCTL_DSP_SETSYNCRO:
	case SOUND_PCM_WRITE_FILTER:
	case SOUND_PCM_READ_FILTER:
		return -EINVAL;
	}
	return -EINVAL;
}

static int ali_open(struct inode *inode, struct file *file)
{
	int i = 0;
	struct ali_card *card = devs;
	struct ali_state *state = NULL;
	struct dmabuf *dmabuf = NULL;
	unsigned int i_scr;
	
	/* find an available virtual channel (instance of /dev/dsp) */
	
	while (card != NULL) {

		/*
		 * If we are initializing and then fail, card could go
		 * away unuexpectedly while we are in the for() loop.
		 * So, check for card on each iteration before we check
		 * for card->initializing to avoid a possible oops.
		 * This usually only matters for times when the driver is
		 * autoloaded by kmod.
		 */
		for (i = 0; i < 50 && card && card->initializing; i++) {
			set_current_state(TASK_UNINTERRUPTIBLE);
			schedule_timeout(HZ / 20);
		}

		for (i = 0; i < NR_HW_CH && card && !card->initializing; i++) {
			if (card->states[i] == NULL) {
				state = card->states[i] = (struct ali_state *) kmalloc(sizeof(struct ali_state), GFP_KERNEL);
				if (state == NULL)
					return -ENOMEM;
				memset(state, 0, sizeof(struct ali_state));
				dmabuf = &state->dmabuf;
				goto found_virt;
			}
		}
		card = card->next;
	}

	/* no more virtual channel avaiable */
	if (!state)
		return -ENODEV;
found_virt:
	/* initialize the virtual channel */

	state->virt = i;
	state->card = card;
	state->magic = ALI5455_STATE_MAGIC;
	init_waitqueue_head(&dmabuf->wait);
	init_MUTEX(&state->open_sem);
	file->private_data = state;
	dmabuf->trigger = 0;
	/* allocate hardware channels */
	if (file->f_mode & FMODE_READ) {
		if ((dmabuf->read_channel =
		     card->alloc_rec_pcm_channel(card)) == NULL) {
			kfree(card->states[i]);
			card->states[i] = NULL;
			return -EBUSY;
		}
		dmabuf->trigger |= PCM_ENABLE_INPUT;
		ali_set_adc_rate(state, 8000);
	}
	if (file->f_mode & FMODE_WRITE) {
		if (codec_independent_spdif_locked > 0) {
			if ((dmabuf->codec_spdifout_channel = card->alloc_codec_spdifout_channel(card)) == NULL) {
				kfree(card->states[i]);
				card->states[i] = NULL;
				return -EBUSY;
			}
			dmabuf->trigger |= SPDIF_ENABLE_OUTPUT;
			ali_set_codecspdifout_rate(state, codec_independent_spdif_locked);	//It must add
			i_scr = inl(state->card->iobase + ALI_SCR);
			if ((i_scr & 0x00300000) == 0x00100000) {
				ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
			} else {
				if ((i_scr & 0x00300000) == 0x00200000) {
					ali_set_spdif_output(state, AC97_EA_SPSA_6_9, codec_independent_spdif_locked);
				} else {
					if ((i_scr & 0x00300000) == 0x00300000) {
						ali_set_spdif_output(state, AC97_EA_SPSA_10_11, codec_independent_spdif_locked);
					} else {
						ali_set_spdif_output(state, AC97_EA_SPSA_7_8, codec_independent_spdif_locked);
					}
				}

			}
		} else {
			if (controller_independent_spdif_locked > 0) {
				if ((dmabuf->controller_spdifout_channel = card->alloc_controller_spdifout_channel(card)) == NULL) {
					kfree(card->states[i]);
					card->states[i] = NULL;
					return -EBUSY;
				}
				dmabuf->trigger |= SPDIF_ENABLE_OUTPUT;
				ali_set_spdifout_rate(state, controller_independent_spdif_locked);
			} else {
				if ((dmabuf->write_channel = card->alloc_pcm_channel(card)) == NULL) {
					kfree(card->states[i]);
					card->states[i] = NULL;
					return -EBUSY;
				}
				/* Initialize to 8kHz?  What if we don't support 8kHz? */
				/*  Let's change this to check for S/PDIF stuff */

				dmabuf->trigger |= PCM_ENABLE_OUTPUT;
				if (codec_pcmout_share_spdif_locked) {
					ali_set_dac_rate(state, codec_pcmout_share_spdif_locked);
					ali_set_spdif_output(state, AC97_EA_SPSA_3_4, codec_pcmout_sha